## 多线程

Java多线程的调度方法有：setPriority（设置优先级），sleep（睡眠），join（加入），yield（让步）；

## 协程 
loom
Quasar

## 父子线程怎么共享数据

InternalThreadLocal



### 线程的6种状态

- 1) NEW：初始状态，线程被构建，但是还没有调用 start 方法;

- 2）RUNNABLED：运行状态，JAVA 线程把操作系统中的就绪和运行两种状态统一称为“运行中” ；

- 3）BLOCKED：阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况 ：

    - 等待阻塞：运行的线程执行了 Thread.sleep 、wait()、 join() 等方法JVM 会把当前线程设置为等待状态，当 sleep 结束、join 线程终止或者线程被唤醒后，该线程从等待状态进入到阻塞状态，重新抢占锁后进行线程恢复；

    - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么jvm会把当前的线程放入到锁池中 ；

    - 其他阻塞：发出了 I/O请求时，JVM 会把当前线程设置为阻塞状态，当 I/O处理完毕则线程恢复；

- 4）WAITING：等待状态，没有超时时间，要被其他线程或者有其它的中断操作；

执行wait()、join()、LockSupport.park()；

- 5）TIME_WAITING：超时等待状态，超时以后自动返回；

执行 Thread.sleep(long)、wait(long)、join(long)、LockSupport.park(long)、LockSupport.parkNanos(long)、LockSupport.parkUntil(long)

- 6）TERMINATED：终止状态，表示当前线程执行完毕 。

---

## 线程池

1 核心线程数
2 最大线程数
3 线程存活时间
4 时间单位
5 阻塞队列
6 线程工厂
7 拒绝策略

线程池的五种状态（Running、Shutdown、Stop、Tidying、Terminated）

任务通常分为两类：cpu密集型、io密集型

- cpu 密集型任务，需要线程长时间进行的复杂的运算，这种类型的任务需要少创建线程，过多的线程将会频繁引起上文切换，降低任务处理处理速度。
- io 密集型任务，由于线程并不是一直在运行，可能大部分时间在等待 IO 读取/写入数据，增加线程数量可以提高并发度，尽可能多处理任务。

因为原生线程池，任务数量大于核心线程数之后，会先把任务放到队列中，等待核心线程处理，这样对于io密集型任务的处理就不合理了，所以需要扩展线程池。

Tomcat扩展线程池，继承ThreadPoolExecutor，重写核心方法execute的处理逻辑，新增TaskQueue继承LinkedBlockingQueue，重写offer方法。

---

### 拒绝策略

ThreadPoolExecutor 也提供了 4 种默认的拒绝策略：

- DiscardPolicy()：丢弃掉该任务，不进行处理。

- DiscardOldestPolicy()：丢弃队列里最近的一个任务，并执行当前任务。

- AbortPolicy()：直接抛出 RejectedExecutionException 异常(默认)。

- CallerRunsPolicy()：既不抛弃任务也不抛出异常，直接使用主线程来执行此任务。


### 说说线程池创建需要的那几个核心参数的含义

ThreadPoolExecutor 最多包含以下七个参数：

- corePoolSize：线程池中的核心线程数

- maximumPoolSize：线程池中最大线程数

- keepAliveTime：闲置超时时间

- unit：keepAliveTime 超时时间的单位（时/分/秒等）

- workQueue：线程池中的任务队列

- threadFactory：为线程池提供创建新线程的线程工厂

- rejectedExecutionHandler：线程池任务队列超过最大值之后的拒绝策略



---

## Netty ？？？

线程模型

IO复用 ？？
