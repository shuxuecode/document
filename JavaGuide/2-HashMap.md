

## 扩容机制

## 扩容因子  0.75








## 一致性哈希算法  todo

---



## 为什么使用红黑树？而不用其它类型的树

其它树比红黑树更难平衡，需要更多的旋转次数

- 链表长度大于8转化为红黑树，小于6红黑树转化为链表；为什么不直接设置成大于8转化成红黑树，小于8转化成链表；（中间有个差值7进行过渡是为了避免链表和树频繁转换，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低）

- 把链表转化为红黑树的阈值是8，为什么不设置成其他值？（遵循泊松分布，链表长度超过8的概率非常小）

- HashMap扩容机制，即resize方法？（JDK 1.7 会重新计算每个元素的哈希值，JDK1.8是通过高位运算（e.hash & oldCap）来确定元素是否需要移动，如果运算结果值为0，那么元素扩容后位置不变，结果值为1表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度）

- HashMap为什么是线程不安全的？（同时新增元素、同时扩容导致数据丢失，jdk1.7头部倒序插入出现死循环导致CPU占用100%）

- HashMap发生哈希冲突，新节点是插入到链表头部还是链表的尾部，头部倒序插入死循环是怎么产生的？（jdk1.7采用头部倒序插入，会导致死循环；jdk1.8使用尾部正序插入）

- ConcurrentHashMap底层采用的结构（分jdk1.7和jdk1.8），jdk1.7和jdk1.8分别采用什么方式实现线程安全？（jdk1.7采用分段锁，也就是为每一个segment加上ReentrantLock锁；jdk1.8使用的是CAS机制加上synchronized锁）

- 

  




## HashSet的底层实现？

（基于HashMap来实现的，new 一个 HashSet对象底层实际就是new了一个HashMap，并且使用默认的初始容量16和默认的加载因子0.75；当我们往HashSet里面添加一个元素其实就是往HashMap里面put了一个元素，并且是以key存在的，HashMap的value值都是一样的，是一个静态常量PRESENT，源码为：`private static final Object PRESENT = new Object();` ）

---

线程安全的List有哪些？（Vector、CopyOnWriteArrayList、还可以使用Collections类的synchronizedList方法将线程不安全的List转为线程安全的）

为什么ArrayList查询速度快？（ArrayList底层是基于数组实现，可以根据元素下标进行查询，查询方式为（数组首地址+元素长度*下标，基于这个位置读取相应的字节数就可以了），如果数组存的是对象，怎么根据下标定位元素所在位置？（对象数组每个元素存放的是对象的引用，而引用类型如果开启指针压缩占用4字节，不开启则占用8字节，所以对象数组同样适用上面的公式）

ArrayList的扩容？（ArrayList底层是基于数组实现，所以创建ArrayList会给数组指定一个初始容量，默认值为10，因为必须指明数组的长度才能给数组分配空间；由于数组的特性，ArrayList扩容是创建一个更大的数组，然后将原来的元素拷贝到更大的数组中，扩容的核心方法是Arrays.copyOf方法）





