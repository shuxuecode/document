

mysql三大范式（1NF即原子性，2NF即消除部分依赖，3NF即消除传递依赖）


## 执行计划？

---

## MySQL高可用方案

### MMM (mysql主主复制)

需两个以上Master，同时只有一个Master对外提供服务

主1出现故障时，自动切换到主2节点，提供服务

缺点：容易丢失事务，已停止维护，不推荐

## MHA（Master High Availability）

MHA包括 Manager节点和Node节点，管理节点一般单独一台机器，Node节点一般和每台MySQL Server在一起。

Node节点通过解析各MySQL日志来进行一些操作，Manager节点将和每个Node节点通信，判断其Node上的MySQL是否正常。若发现故障，则直接把他的Slave提升为Master，其他Slave都挂到新Master上，此过程过程对用户透明。

## MGR （MySQL Group Replication）

1. 5.7.17 版本后官方正式推出的一种组复制机制
2. 核心解决异步复制和半同步复制数据一致性问题
3. 原理：若干节点组成复制组，一个事务发起提交，必须经过半数节点以上的决议通过，才可正常提交。
4. 依靠分布式一致性协议，Paxos的一个变种
5. 实现分布式场景下，数据最终一致
6. 支持多主，但官方推荐单主模式
   - 多主：客户端可随机向MySQL节点写入数据
   - 单主：集群选出主节点复制写，主和其他节点提供读
7. 优点：几乎无延迟，相比异步复制小很多，数据强一致性，可保证实物不丢失。
8. 不足：仅支持Innodb，每个表必须有主键，且只能在GTID模式下使用，总体上目前还不够成熟，未经太多大型生产环境验证
9. 适用场景：对主从延迟敏感，希望提供些服务高可用，希望数据强一致性。



---


## 优化

- 逻辑表超过5000万-到1亿的，可以适当拆分表，一般情况下，mysql建议单表数量维持在10万以上到1000万一下性能最好
- 单库建议，一般来说建议维持在1T以内，超过1T的最好采取分库策略
- TPS/QPS :一般来说建议单库TPS不超过1500，QPS不超过3000，如果业务量持续超过，可以考虑分库

## 存储引擎

Myisam和InnoDB存储引擎的区别？（Myisam不支持外键也不支持事务，支持的是表锁，当执行select操作时，自动给涉及的表加表锁，当执行增删改操作，自动给涉及的表加写锁；InnoDB支持外键也支持事务，支持的是行锁，当执行select操作时，不加任何锁，当执行增删改操作，自动给涉及的行加写锁）



---

## 四大特性？

ACID

## 隔离级别

- 读未提交
- 读提交
- 可重复读
- 串行化

并发事务处理带来的四种问题和事务的隔离级别（丢失更新、脏读、不可重复读、幻读；读未提交、读已提交、可重复读、串行化）

![img](img\2021-02-18-13-58-nxkJ2Bz8itIhWKU.png)
注：√代表可能发生，×代表不可能发生

幻读怎么解决？？

## 事务

事务的ACID属性是如何实现的？
（原子性通过回滚日志undo log实现；持久性通过重做日志redo log实现；隔离性通过锁和MVCC实现；而一致性则是通过原子性、隔离性、持久性来实现，只有满足这三个特性，才能实现事务的一致性）

## 锁



## 索引

聚簇索引
非聚簇索引
执行计划
count1*区别？

联合索引？？

### 



索引失效的情况？（违反最左前缀法则、范围查询右边的列索引失效、字符串不加单引号、对索引列进行运算、头部模糊匹配、使用不等于！=或者<>）

explain分析执行计划、SQL语句的优化

## B+树

![img](img\B+tree.png)

#### B+树和B-树的主要区别如下：

- B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。
- B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。
- 查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束
- B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。

（B+树IO次数更少、更适合范围查询、查询效率更加稳定）

（哈希表不支持范围查找）

### B+树的插入

B+树插入要记住这几个步骤：

- 1.B+树插入都是在叶子结点进行的，就是插入前，需要先找到要插入的叶子结点。
- 2.如果被插入关键字的叶子节点，当前含有的关键字数量是小于阶数m，则直接插入。
- 3.如果插入关键字后，叶子节点当前含有的关键字数目等于阶数m，则插，该节点开始 **「分裂」**为两个新的节点，一个节点包含⌊m/2⌋ 个关键字，另外一个关键字包含⌈m/2⌉个关键值。（⌊m/2⌋表示向下取整，⌈m/2⌉表示向上取整，如⌈3/2⌉=2）。
- 4.分裂后，需要将第⌈m/2⌉的关键字上移到父结点。如果这时候父结点中包含的关键字个数小于m，则插入操作完成。
- 5.分裂后，需要将⌈m/2⌉的关键字上移到父结点。如果父结点中包含的关键字个数等于m，则继续分裂父结点。

以一颗4阶的B+树为例子吧，4阶的话，关键值最多3（m-1）个。假设插入以下数据43，48，36，32,37,49,28.

1. 在空树中插入43

![](img/2021-02-22-20-51-54.png)

这时候根结点就一个关键值，此时它是根结点也是叶子结点。

2. 依次插入48，36

![](img/2021-02-22-20-52-28.png)

这时候跟节点拥有3个关键字，已经满了

3. 继续插入 32，发现当前节点关键字已经不小于阶数4了，于是分裂 第⌈4/2⌉=2（下标0,1,2）个，也即43上移到父节点。

![](img/2021-02-22-20-53-08.png)

4. 继续插入37，49，前节点关键字都是还没满的，直接插入，如下：

![](img/2021-02-22-20-53-14.png)

5. 最后插入28，发现当前节点关键字也是不小于阶数4了，于是分裂，于是分裂， 第 ⌈4/2⌉=2个，也就是36上移到父节点，因父子节点只有2个关键值，还是小于4的，所以不用继续分裂，插入完成

![](img/2021-02-22-20-53-20.png)






### 红黑树：红黑树是一颗特殊的二叉查找树，每个节点都是黑色或者红色，根节点、叶子节点是黑色。如果一个节点是红色的，则它的子节点必须是黑色的。

## binlog  归档日志

> 作用：用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。 
用于数据库的基于时间点的还原。

## redo log 重做日志
是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。

> 作用： 确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

持久性依赖 redo log实现

### redo log和binlog区别

- redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。
- redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑
- redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。
- binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。

## undo log 回滚日志

> 作用：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读


## MVCC机制  ?
多版本数据放在哪里？





## 分库分表

从拆分角度，可分为水平拆分与垂直拆分。

- 垂直拆分：按业务进行归类，将数据拆分到不同库或表中。不可彻底解决大数据量存储瓶颈。
- 水平拆分：根据业务逻辑，将数据通过某些字段，分散存储到多个库或表中，每个分片斤包括一部分数据。

常用分片策略：

- 取模：数据均匀分布，扩容麻烦
- 按范围：比较好扩容，数据不够均衡
- 按时间：容易区分弱点数据
- 按枚举：如按地区
- 按目标字段前缀


## 异步复制、全同步复制与半同步复制

### 一、异步复制（Asynchronous replication）
1、逻辑上

MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从库上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。

2、技术上

主库将事务 Binlog 事件写入到 Binlog 文件中，此时主库只会通知一下 Dump 线程发送这些新的 Binlog，然后主库就会继续处理提交操作，而此时不会保证这些 Binlog 传到任何一个从库节点上。

### 二、全同步复制（Fully synchronous replication）

1、逻辑上

指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。

2、技术上

当主库提交事务之后，所有的从库节点必须收到、APPLY并且提交这些事务，然后主库线程才能继续做后续操作。但缺点是，主库完成一个事务的时间会被拉长，性能降低。

### 三、半同步复制（Semisynchronous replication）

1、逻辑上

是介于全同步复制与全异步复制之间的一种，主库只需要等待至少一个从库节点收到并且 Flush Binlog 到 Relay Log 文件即可，主库不需要等待所有从库给主库反馈。同时，这里只是一个收到的反馈，而不是已经完全完成并且提交的反馈，如此，节省了很多时间。

2、技术上

介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。

## todo

mysql行锁最大并发数？（秒杀项目指出）