
## 什么是线程安全

线程安全就是多线程访问的时候，采用了加锁机制，当一个线程访问该类的某个数据的时候，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可以使用，不会出现数据不一致或者数据污染。 

---

线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

---

那么为什么ArrayList为什么线程不安全呢？我们知道ArrayList在添加一个元素的时候，需要两个步骤，第一步在Items[Size]的位置存放此元素，第二步增大Size的值，在单线程运行的情况，比如两个苹果两个人吃，一个人吃一个，这个是并发的，互不影响，但是如果一个人吃两个苹果，要保证同时吃完，就需要这个苹果吃一点，停下来再去吃一点另一个苹果，既然Add方法内部是需要分两步走，那就是线程A在0的位置赋了一个值，然后停下来去B线程ArrayList 0的位置又赋了一个值，其实是重复在一个位置赋值，然后回到A线程，执行Size增加，也就是ArrayList的大小增加了，原来Size是1，现在变成2，然后停下来继续执行线程B，又增加了一个空间位置，size大小就变成了3，结果就是0的位置有值，1和2的索引位置都没有值实际大小是3，跟想要的结果0和1赋不同的值，结果不对，so线程不安全。


---


## 线程同步机制（voliate,synchronized,重入锁，threadlocal），线程间通信（wait,notify）


## 如何确保N个线程可以访问N个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。




## 选择合适的阻塞队列

> 所有的阻塞队列都可以被用来存放任务，但是使用不同的队列针对corePoolSize会表现不同的行为：

> 当池中工作线程数小于corePoolSize的时候，每次来任务的时候都会创建一个新的工作线程。

> 当池中工作线程数大于等于corePoolSize的时候，每次任务来的时候都会首先尝试将线程放入队列，而不是直接去创建线程。

> 如果放入队列失败，且当先池中线程数小于maximumPoolSize的时候，则会创建一个工作线程。

下面主要是不同队列策略表现:

- 直接递交：一种比较好的默认选择是使用SynchronousQueue，这种策略会将提交的任务直接传送给工作线程，而不持有。如果当前没有工作线程来处理，即任务放入队列失败，则根据线程池的实现，会引发新的工作线程创建，因此新提交的任务会被处理。这种策略在当提交的一批任务之间有依赖关系的时候避免了锁竞争消耗。值得一提的是，这种策略最好是配合unbounded线程数来使用，从而避免任务被拒绝。同时我们必须要考虑到一种场景，当任务到来的速度大于任务处理的速度，将会引起无限制的线程数不断的增加。

- 无界队列：使用无界队列如LinkedBlockingQueue没有指定最大容量的时候，将会引起当核心线程都在忙的时候，新的任务被放在队列上，因此，永远不会有大于corePoolSize的线程被创建，因此maximumPoolSize参数将失效。这种策略比较适合所有的任务都不相互依赖，独立执行。举个例子，如网页服务器中，每个线程独立处理请求。但是当任务处理速度小于任务进入速度的时候会引起队列的无限膨胀。

- 有界队列：有界队列如ArrayBlockingQueue帮助限制资源的消耗，但是不容易控制。队列长度和maximumPoolSize这两个值会相互影响，使用大的队列和小maximumPoolSize会减少CPU的使用、操作系统资源、上下文切换的消耗，但是会降低吞吐量，如果任务被频繁的阻塞如IO线程，系统其实可以调度更多的线程。使用小的队列通常需要大maximumPoolSize，从而使得CPU更忙一些，但是又会增加降低吞吐量的线程调度的消耗。总结一下是IO密集型可以考虑多些线程来平衡CPU的使用，CPU密集型可以考虑少些线程减少线程调度的消耗。








